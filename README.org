#+TITLE: Org-roam extension to the browser

This browser plugin gives you the ability to display that you've
captured information on a page in org-roam

* Using this addon

** Start the elisp webserver
   Install the web-server package with ~M-x package-install web-server~.
   
   Evaluate the [[./elisp-server/org-roam-browser-server.el]] file from this repository.
   
** Load the browser plugin
   1. Open up Firefox
   2. Browse to [[about:debugging]]
   3. Click "This Firefox"
   4. Click Load Temporary Add-on
   5. Select the manifest or js file & enjoy the plugin

* How this works
  The plugin consists of two parts: a browser plugin and an elisp web
  service.  They go hand-in-hand to supply the necessary information
  to the browser.

** Browser plugin
   The browser plugin shows a pageAction to indicate whether we've
   found links on the current page or not.

   A browser plugin consists of a manifest file and a source-file.

*** Manifest
    The manifest file mainly supplies metadata of the browser plugin.
    Most of this is metadata.  Note that we fetch the =tabs= and
    =activeTab= permissions so we can figure out what URL the user is
    browsing.

    The logo we're using here is CC-by-SA and is included as such, it
    was designed by @nobiot for org-roam.

    #+begin_src json :tangle ./browser-extension/manifest.json
      {
        "manifest_version": 2,
        "name": "org-roam monitor",
        "version": "0.0.1",
        "description": "Shows whether or not you have an org-roam page for the currently visited site.",
        "icons": {
          "48": "org-roam-logo.svg",
          "96": "org-roam-logo.svg"
        },

        "background": {
          "scripts": ["roam.js"]
        },

        "page_action": {
          "default_icon": "org-roam-logo-inactive.svg",
          "browser_style": true
        },

        "permissions": [
          "activeTab",
          "tabs"
        ]
      }
    #+end_src

*** Browser plugin implementation
    :PROPERTIES:
    :header-args: :tangle ./browser-extension/roam.js
    :END:
    
    For each visible tab, whenever it is updated too, we want to
    figure out what page we're visiting.

    First thing we do is figure out the current URL.  We split off the
    protocol because that's what roam does internally (this would
    better be served in the elisp world and it may change).

    Once we have that, we ask the org-roam backend server if there is
    any info on the page.  If there is, then we render a positive
    pageIcon, otherwise a negative one.

    #+begin_src javascript
      /**
       ,* Initialize the page action: set icon and title, then show.
       ,*/
      async function initializePageAction(tab) {
        const urlNoProtocol = tab.url.slice((new URL(tab.url)).protocol.length);
        const fetched = await fetch(`http://localhost:10001/roam/info?url=${urlNoProtocol}`);
        const body = await fetched.json();

        const pageExists = body.pageExists;
        const linkExists = body.linkExists;
        const parentKnown = body.parentKnown;

        let iconUrl;
        let title;
        if( pageExists ) {
          iconUrl = "org-roam-logo-has-page.svg";
          title = "Has page";
        } else if( linkExists ) {
          iconUrl = "org-roam-logo-has-link.svg";
          title = "Has link";
        } else if( parentKnown ) {
          iconUrl = "org-roam-logo-has-upper-reference.svg";
          title = "Parent is known";
        } else {
          iconUrl = "org-roam-logo-inactive.svg";
          title = "Nothing found";
        }

        browser.pageAction.setIcon({ tabId: tab.id, path: iconUrl });
        browser.pageAction.setTitle({ tabId: tab.id, title });
        browser.pageAction.show(tab.id);
      }
    #+end_src

    We need to ensure the above function is called whenever a tab is updated.

    #+begin_src javascript
      /**
       ,*  Each time a tab is updated, reset the page action for that tab.
       ,*/
      browser.tabs.onUpdated.addListener((id, changeInfo, tab) => {
        initializePageAction(tab);
      });
    #+end_src

    We also want to update when we load this plugin for the first time.

    #+begin_src javascript
      /**
       ,* When first loaded, initialize the page action for all tabs.
       ,*/
      browser
        .tabs
        .query({})
        .then((tabs) => {
          for (let tab of tabs) {
            console.log("Initializing TAB");
            initializePageAction(tab);
          }
        });
    #+end_src

** The elisp server
   :PROPERTIES:
   :header-args: :tangle ./elisp-server/org-roam-browser-server.el :comments link
   :END:
   
   All elisp packages start with a prologue
   #+begin_src emacs-lisp
     ;;; org-roam-browser-server -- A package providing information to the browser on what you have stored in org-roam.

     ;;; Commentary:
     ;;;
     ;;; More information at https://github.com/madnificent/org-roam-browser-server.git

     ;;; Code:
   #+end_src

   Turns out there's a super simple emacs webserver we can use.  We
   just open it on port 10001.

   #+begin_src emacs-lisp
     (ws-start
      'org-roam-server-handler
      10001)
   #+end_src

   The handler function needs to look up a bunch of URLs.  To simplify
   that, we draft a function to help split a URL in its interesting
   parts.

   The funtion generates too much matches, but it's sufficient for our
   current tests.

   #+begin_src emacs-lisp
     (defun org-roam-browser-server--sub-urls (url)
       "Generate a list of sub-urls from URL."
       (when (string-prefix-p "//" url)
         (reduce (lambda (acc val)
                   (let ((start (first acc)))
                     `(,(concat start val "/")
                       ,(concat start val)
                       ,@acc)))
                 (split-string (string-trim url "//") "/" "")
                 :initial-value '("//"))))))
   #+end_src

   Next up we define two functions for checking if there are
   interesting documents in the database.  One checks if one of an
   array of links can be found, the second checks if a page with the
   given reference exists.

   #+begin_src emacs-lisp
     (defun org-roam-browser-server--reference-exists-as-key (&rest references)
       "Verify if any of REFERENCES is known in org-roam."
       (org-roam-db-query
        [:select file :from refs
         :where ref :in $v1]
        (apply #'vector references)))

     (defun org-roam-browser-server--reference-exists-as-link (&rest references)
       "Verify if any of REFERENCES is referred to in org-roam."
       (org-roam-db-query
        [:select source
         :from links
         :where links:dest :in $v1]
        (apply #'vector references)))
   #+end_src

   The handler function becomes simple.  It receives the stripped URL
   and just has to respond with wether we have info on this or not.

   As an added complexity, it also checks if any of the parent URLs is
   found or referenced, based on previous functions.

   We set the Access-Control-Allow-Origin header to indicate to the
   browser that this API can be used from external sites (our addon
   would otherwise not be allowed to load this resource).

   #+begin_src emacs-lisp
     (defun org-roam-server-handler (request)
       (with-slots (process headers) request
         (ws-response-header process 200 '("Content-type" . "application/json") '("Access-Control-Allow-Origin" . "*"))
         (process-send-string
          process
          (let ((url (cdr (assoc "url" headers))))
            (let ((page-exists (org-roam-browser-server--reference-exists-as-key url))
                  (page-referenced (org-roam-browser-server--reference-exists-as-link url))
                  (parent-known
                   (let ((parent-list (org-roam-browser-server--sub-urls url)))
                     (or (apply #'org-roam-browser-server--reference-exists-as-key parent-list)
                         (apply #'org-roam-browser-server--reference-exists-as-link parent-list)))))
              (concat
               "{\"pageExists\": " (if page-exists "true" "false") ",\n"
               " \"linkExists\": " (if page-referenced "true" "false") ",\n"
               " \"parentKnown\": " (if parent-known "true" "false") " }"))))))
   #+end_src

   #+RESULTS:
   : org-roam-server-handler

   And we end with providing this package:

   #+begin_src emacs-lisp
     (provide 'org-roam-browser-server)
     ;;; org-roam-browser-server.el ends here
   #+end_src

* Next steps
  This is a PoC.  If we want it to stick around, it should evolve into
  something more extensive.

  Obvious things that spring to mind:
  
  - [ ] Move stripping of protocol into elisp land
  - [X] Add icon to indicate a hyperlink to a page was found
  - [ ] Add action to show/create an org-roam page for the current site
  - [X] Add indication that a parent page was found in org-roam
  - [ ] Make port configurable
  - [ ] Release this on known platforms
  - [ ] Check if WebExtension#browserAction would be nicer than WebExtension#pageActionp
